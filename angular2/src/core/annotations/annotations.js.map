{"version":3,"sources":["@traceur/generated/TemplateParser/5368","@traceur/generated/TemplateParser/5367","@traceur/generated/TemplateParser/5366","@traceur/generated/TemplateParser/5371","@traceur/generated/TemplateParser/5369","@traceur/generated/TemplateParser/5374","angular2/src/core/annotations/annotations.js","@traceur/generated/TemplateParser/13","angular2/src/core/annotations/@traceur/generated/TemplateParser/24","angular2/src/core/annotations/@traceur/generated/TemplateParser/23","angular2/src/core/annotations/@traceur/generated/TemplateParser/25","angular2/src/core/annotations/@traceur/generated/TemplateParser/26","@traceur/generated/TemplateParser/884","@traceur/generated/TemplateParser/5370"],"names":[],"mappings":"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","file":"angular2/src/core/annotations/annotations.js","sourceRoot":"/Users/jbisa/ksi/devel/angular2/dist/js/dev/es6/","sourcesContent":["System.register($__placeholder__0, function($__export) {\n          $__placeholder__1\n        });","return {\n      setters: $__placeholder__0,\n      execute: $__placeholder__1\n    }","function($__m) {\n          $__placeholder__0\n        }","$__placeholder__0 = $__m.$__placeholder__1;","var $__placeholder__0 = $__export($__placeholder__1, $__placeholder__2);","function($__super) {\n          var $__placeholder__0 = $__placeholder__1;\n          return ($traceurRuntime.createClass)($__placeholder__2, $__placeholder__3,\n                                               $__placeholder__4, $__super);\n        }($__placeholder__5)","import {ABSTRACT, CONST, normalizeBlank, isPresent} from 'angular2/src/facade/lang';\nimport {ListWrapper, List} from 'angular2/src/facade/collection';\nimport {Injectable} from 'angular2/di';\n\n// type StringMap = {[idx: string]: string};\n\n/**\n * Directives allow you to attach behavior to elements in the DOM.\n *\n * Directive is an abstract concept, instead use concrete directives: [Component], [DynamicComponent], [Decorator] \n * or [Viewport].\n *\n * A directive consists of a single directive annotation and a controller class. When the directive's [selector] matches\n * elements in the DOM, the following steps occur:\n *\n * 1. For each directive, the [ElementInjector] attempts to resolve the directive's constructor arguments.\n * 2. Angular instantiates directives for each matched element using [ElementInjector].\n *\n * ## Understanding How Injection Works\n * \n * There are three stages of injection resolution.\n * - *Pre-existing Injectors*: \n *   - The terminal [Injector] cannot resolve dependencies. It either throws an error or, if the dependency was \n *     specified as `@Optional`, returns `null`.\n *   - The primordial injector resolves browser singleton resources, such as: cookies, title, location, and others.\n * - *Component Injectors*: Each `@Component` has its own [Injector], and they follow the same parent-child hierachy \n *     as the components in the DOM.\n * - *Element Injectors*: Each component has a Shadow DOM. Within the Shadow DOM each element has an [ElementInjector] \n *  which follow the same parent-child hiercachy as the DOM elements themselves.\n * \n * When resolving dependencies, the current injector is asked to resolve the dependency first, and if it does not \n * have it, it delegates to the parent injector. \n * \n * Angular then resolves dependencies as follows, according to the order in which they appear in the [View]:\n * \n * 1. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\n * 2. Dependencies on component injectors and their parents until it encounters the root component\n * 3. Dependencies on pre-existing injectors\n * \n * \n * The [ElementInjector] can inject other directives, element-specific special objects, or can delegate to the parent \n * injector.\n * \n * To inject other directives, declare the constructor parameter as:\n *    - `directive:DirectiveType`: a directive on the current element only\n *    - `@Ancestor() d:Type`: any directive that matches the type between the current element (excluded) and the Shadow DOM root [TODO: what does (excluded) mean? Does this apply to the @Parent annotation also?]\n *    - `@Parent() d:Type`: any directive that matches the type on a direct parent element only\n *    - `@Children query:Query<Type>`: A live collection of direct child directives\n *    - `@Descendants query:Query<Type>`: A live collection of any child directives\n * \n * To inject element-specific special objects, declare the constructor parameter as:\n *    - `element: NgElement` to obtain a DOM element (DEPRECATED: replacment coming)\n *    - `viewContainer: ViewContainer` to control child template instantiation, for [Viewport] directives only\n *    - `bindingPropagation: BindingPropagation` to control change detection in a more granular way\n * \n * ## Example\n *\n * The following example demonstrates how dependency injection resolves constructor arguments in practice.\n *\n *\n * Assume this HTML structure:\n *\n * ```\n * <div dependency=\"1\">\n *   <div dependency=\"2\">\n *     <div dependency=\"3\" my-directive>\n *       <div dependency=\"4\">\n *         <div dependency=\"5\"></div>\n *       </div>\n *       <div dependency=\"6\"></div>\n *     </div>\n *   </div>\n * </div>\n * ```\n *\n * With the following `dependency` decorator and `SomeService` injectable class.\n *\n * ```\n * @Injectable()\n * class SomeService {\n * }\n *\n * @Decorator({\n *   selector: '[dependency]',\n *   bind: {\n *     'id':'dependency'\n *   }\n * })\n * class Dependency {\n *   id:string;\n * }\n * ```\n *\n * Let's step through the different ways in which `MyDirective` could be declared...\n *\n * ### No injection\n *\n * Here the constructor is declared with no arguments, so nothing is injected into `MyDirective`.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor() {\n *   }\n * }\n * ```\n *\n * This directive would return nothing for the example code above. [TODO: True? We spent a lot of time talking about \n * errors but in this case, there's nothing to error on, right? I don't understand the diff between \"returns\" and \"injects\" \n * when the example is showing a directive not the template. Which is the correct verb?]\n *\n * ### Component-level injection\n *\n * Directives can inject any injectable instance from the closest component injector or any of its parents.\n *\n * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type from the parent\n * component's injector.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(someService: SomeService) {\n *   }\n * }\n * ```\n *\n * This directive would return `dependency=3` for the example code above. [TODO: True? Is \"return\" the right verb?]\n * \n * ### Injecting a directive from the current element\n *\n * Directives can inject other directives declared on the current element.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n * This directive would also return `dependency=3` for the example code above. [TODO: True? Why is this the same?]\n * \n *\n * ### Injecting a directive from a direct parent element\n *\n * Directives can inject other directives declared on a direct parent element. By definition, a directive with a \n * `@Parent` annotation does not attempt to resolve dependencies for the current element, even if this would satisfy\n * the dependency. [TODO: did I get the subject/verb right?]\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Parent() dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n * This directive would return `dependency=2` for the example code above. [TODO: True?]\n * \n * ### Injecting a directive from any ancestor elements\n *\n * Directives can inject other directives declared on any ancestor element, i.e. on the parent element and its parents.  \n * By definition, a directive with an `@Ancestor` annotation does not attempt to resolve dependencies for the current \n * element, even if this would satisfy the dependency. [TODO: did I get the subject/verb right? ]\n *\n *  Unlike the `@Parent` which only checks the parent `@Ancestor` checks the parent, as well as its\n * parents recursivly. If `dependency=\"2\"` would not be present this injection would return `dependency=\"1\"`.\n\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Ancestor() dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n * \n * This directive would also return `dependency=2` for the example code above. If `dependency=2` hadn't been declared \n * on the parent `div`, this directive would return `d[TODO: True?]\n *\n * ### Injecting query of child directives. [PENDING IMPLEMENTATION]\n *\n * In some cases the directive may be interersted in injecting its child directives. This is not directly possible\n * since parent directives are guarteed to be created before child directives. Instead we can injecto a container\n * which can than be filled once the data is needed.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Children() dependencys:Query<Maker>) {\n *     // dependencys will eventuall contain: [4, 6]\n *     // this will upbate if children are added/removed/moved,\n *     // for example by having for or if.\n *   }\n * }\n * ```\n *\n *\n * ### Injecting query of descendant directives. [PENDING IMPLEMENTATION]\n *\n * Similar to `@Children` but also includ childre of those children.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Children() dependencys:Query<Maker>) {\n *     // dependencys will eventuall contain: [4, 5, 6]\n *     // this will upbate if children are added/removed/moved,\n *     // for example by having for or if.\n *   }\n * }\n * ```\n *\n *\n * ### Optional injection\n *\n * Finally there may be times when we would like to inject a component which may or may not be there. For this\n * use case angular supports `@Optional` injection.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Optional() @Ancestor() form:Form) {\n *     // this will search for a Form directive above itself,\n *     // and inject null if not found\n *   }\n * }\n * ```\n *\n * @publicModule angular2/annotations\n */\n@ABSTRACT()\nexport class Directive extends Injectable {\n  /**\n   * The CSS selector that triggers the instantiation of a directive.\n   *\n   * Angular only allows directives to trigger on CSS selectors that do not cross element boundaries.\n   * The supported selectors are:\n   *\n   * - `element-name` select by element name.\n   * - `.class` select by class name.\n   * - `[attribute]` select by attribute name.\n   * - `[attribute=value]` select by attribute name and value.\n   * - `:not(sub_selector)` select only if the element does not match the `sub_selector`.\n   *\n   * ## Example\n   *\n   * Suppose we have a directive with an `input[type=text]` selector.\n   *\n   * And the following HTML:\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   * The directive would only be instantiated on the `<input type=\"text\">` element.\n   *\n   */\n  selector:string;\n\n  /**\n   * Enumerates the set of properties that accept data binding for a directive.\n   *\n   * The `bind` property defines a set of `directiveProperty` to `bindingProperty` key-value pairs:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * You can include [Pipes] when specifying a `bindingProperty` to allow for data transformation and structural\n   * change detection of the value.\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   bind: {\n   *     'directiveProperty1': 'bindingProperty1',\n   *     'directiveProperty2': 'bindingProperty2 | pipe1 | ...',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   *\n   * ## Basic Property Binding:\n   *\n   * ```\n   * @Decorator({\n   *   selector: '[tooltip]',\n   *   bind: {\n   *     'tooltipText': 'tooltip'\n   *   }\n   * })\n   * class Tooltip {\n   *   set tooltipText(text) {\n   *     // This will get called every time the 'tooltip' binding changes with the new value.\n   *   }\n   * }\n   * ```\n   *\n   * As used in this example:\n   *\n   * ```html\n   * <div [tooltip]=\"someExpression\">\n   * ```\n   *\n   * Whenever the `someExpression` expression changes, the `bind` declaration instructs Angular to update the\n   * `Tooltip`'s `tooltipText` property.\n   *\n   *\n   * Similarly in this example:\n   *\n   * ```html\n   * <div tooltip=\"Some Text\">\n   * ```\n   *\n   * The `Tooltip`'s `tooltipText` property gets initialized to the `Some Text` literal.\n   *\n   *\n   * ## Bindings With Pipes:\n   *\n   * ```\n   * @Decorator({\n   *   selector: '[class-set]',\n   *   bind: {\n   *     'classChanges': 'classSet | keyValDiff'\n   *   }\n   * })\n   * class ClassSet {\n   *   set classChanges(changes:KeyValueChanges) {\n   *     // This will get called every time the `class-set` expressions changes its structure.\n   *   }\n   * }\n   * ```\n   *\n   * As used in this example:\n   *\n   * ```html\n   * <div [class-set]=\"someExpression\">\n   * ```\n   *\n   * In the above example, the `ClassSet` uses the `keyValDiff` [Pipe] for watching structural changes. This means that\n   * the `classChanges` setter gets invoked if the expression changes to a different reference, or if the\n   * structure of the expression changes. (Shallow property watching of the object)\n   *\n   * NOTE: The `someExpression` can also contain its own [Pipe]s. In this case, the two pipes compose as if they were\n   * inlined.\n   *\n   */\n  bind:any; //  StringMap\n\n  /**\n   * Specifies which DOM events the directive listens to and what the action should be when they occur.\n   *\n   * The `events` property defines a set of `event` to `method` key-value pairs:\n   *\n   * - `event1` specifies the DOM event that the directive listens to.\n   * - `onMethod1` specifies the method to execute when the event occurs.\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   events: {\n   *     'event1': 'onMethod1',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Basic Event Binding:\n   *\n   * ```\n   * @Decorator({\n   *   selector: 'input',\n   *   events: {\n   *     'change': 'onChange'\n   *   }\n   * })\n   * class InputDecorator {\n   *   onChange(event:Event) {\n   *     // invoked whenever the DOM element fires the 'change' event.\n   *   }\n   * }\n   * ```\n   *\n   */\n  events:any; //  StringMap\n\n  /**\n   * Specifies a set of lifecycle events in which the directive participates.\n   *\n   * See: [onChange], [onDestroy] for details.\n   */\n  lifecycle:List; //List<LifecycleEvent>\n\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle\n    }:{\n      selector:string,\n      bind:any,\n      events: any,\n      lifecycle:List\n    }={})\n  {\n    super();\n    this.selector = selector;\n    this.bind = bind;\n    this.events = events;\n    this.lifecycle = lifecycle;\n  }\n\n  /**\n   * Returns true if a directive participates in a given [LifecycleEvent].\n   */\n  hasLifecycleHook(hook:string):boolean {\n    return isPresent(this.lifecycle) ? ListWrapper.contains(this.lifecycle, hook) : false;\n  }\n}\n\n/**\n * Components are angular directives with Shadow DOM views.\n *\n * Componests are used to encapsulate state and template into reusable building blocks. An angular component requires\n * an `@Component` and at least one `@Template` annotation (see [Template] for more datails.) Components instances are\n * used as the context for evaluation of the Shadow DOM view.\n *\n * Restrictions:\n * - Thre can anly be one component per DOM element.\n *\n * ## Example\n *     @Component({\n *       selector: 'greet'\n *     })\n *     @Template({\n *       inline: 'Hello {{name}}'\n *     })\n *     class Greet {\n *       name: string;\n *\n *       constructor() {\n *         this.name = 'World';\n *       }\n *     }\n *\n * @publicModule angular2/annotations\n */\nexport class Component extends Directive {\n  /**\n   * Defines the set of injectables that are visible to a Component and its children.\n   *\n   * When a [Component] defines [injectables], Angular creates a new application-level [Injector] for the component\n   * and its children. Injectables are defined as a list of [Binding]s, (or as [Type]s as short hand). These bindings\n   * are passed to the [Injector] constructor when making a new child [Injector]. The injectables are available for\n   * all child directives of the Component (but not the declaring component's light DOM directives).\n   *\n   * ## Example\n   *     // Example of a class which we would like to inject.\n   *     class Greeter {\n   *        salutation:string;\n   *\n   *        constructor(salutation:string) {\n   *          this.salutation = salutation;\n   *        }\n   *\n   *        greet(name:string) {\n   *          return this.salutation + ' ' + name + '!';\n   *        }\n   *     }\n   *\n   *     @Component({\n   *       selector: 'greet',\n   *       services: [\n   *         bind(String).toValue('Hello'), // Configure injection of string\n   *         Greeter // Make Greeter available for injection\n   *       ]\n   *     })\n   *     @Template({\n   *       inline: '<child></child>',\n   *       directives: Child\n   *     })\n   *     class Greet {\n   *       greeter: Greeter;\n   *\n   *       constructor(greeter: Greeter) {\n   *         // Greeter can be injected here becouse it was declared as injectable\n   *         // in this component, or parent component.\n   *         this.greeter = greeter;\n   *       }\n   *     }\n   *\n   *     @Decorator({\n   *       selector: 'child'\n   *     })\n   *     class Child {\n   *       greeter: Greeter;\n   *\n   *       constructor(greeter: Greeter) {\n   *         // Greeter can be injected here becouse it was declared as injectable\n   *         // in a an ancestor component.\n   *         this.greeter = greeter;\n   *       }\n   *     }\n   *\n   *\n   * Let's look at the [services] part of the example above.\n   *\n   *     services: [\n   *         bind(String).toValue('Hello'),\n   *         Greeter\n   *     ]\n   *\n   * Here the `Greeter` is a short hand for `bind(Greeter).toClass(Greeter)`. See [bind] DSL for more details.\n   */\n  services:List;\n\n@CONST()\n  constructor({\n    selector,\n    bind,\n    events,\n    services,\n    lifecycle\n    }:{\n      selector:String,\n      bind:Object,\n      events:Object,\n      services:List,\n      lifecycle:List\n    }={})\n  {\n    super({\n      selector: selector,\n      bind: bind,\n      events: events,\n      lifecycle: lifecycle\n    });\n\n    this.services = services;\n  }\n}\n\n/**\n * DynamicComponents allow loading child components impretivly.\n * \n * A Component can be made of other compontents. This recursive nature must be resolved synchronously during the \n * component template processing. This means that all templates are resolved synchronously. This prevents lazy loading\n * of code or delayed binding of views to the components. \n * \n * A DynamicComponent is a placeholder into which a regular component can be loaded imperativly and thus breaking\n * the all components must be resolved synchronously restriction. Once loaded the component is premanent.\n * \n * \n * ## Example\n * @DynamicComponent({\n *   selector: 'dynamic-comp'\n * })\n * class DynamicComp {\n *   done;\n *   constructor(loader:PrivateComponentLoader, location:PrivateComponentLocation) {\n *     this.done = loader.load(HelloCmp, location);\n *   }\n * }\n * \n * @Component({\n *   selector: 'hello-cmp'\n * })\n * @Template({\n *   inline: \"{{greeting}}\"\n * })\n * class HelloCmp {\n *   greeting:string;\n *   constructor() {\n *     this.greeting = \"hello\";\n *   }\n * }\n * \n * \n * @publicModule angular2/annotations\n */\nexport class DynamicComponent extends Directive {\n  services:any; //List;\n\n  @CONST()\n  constructor({\n    selector,\n    bind,\n    events,\n    services,\n    lifecycle\n    }:{\n      selector:string,\n      bind:Object,\n      events:Object,\n      services:List,\n      lifecycle:List\n    }={}) {\n    super({\n      selector: selector,\n      bind: bind,\n      events: events,\n      lifecycle: lifecycle\n    });\n\n    this.services = services;\n  }\n}\n\n/**\n * Decorators allow attaching behavior to DOM elements in a composable manner.\n *\n * Decorators:\n * - are simplest form of [Directive]s.\n * - are besed used as compostinion pattern ()\n *\n * Decoraters differ from [Component]s in that they:\n * - can have any number of decorators per element\n * - do not create their own evaluation context\n * - do not have template (and therefor do not create Shadow DOM)\n *\n * ## Example\n *\n * Let's say we would like to add tool-tip behavior to any alement.\n *\n * ```\n * <div tooltip=\"some text here\"></div>\n * ```\n *\n * We could have a decorator directive like so:\n *\n * ```\n * @Decorator({\n *   selector: '[tooltip]',\n *   bind: {\n *     'text': 'tooltip'\n *   },\n *   event: {\n *     'onmouseenter': 'onMouseEnter',\n *     'onmouseleave': 'onMouseLeave'\n *   }\n * })\n * class Tooltip{\n *   text:string;\n *   overlay:Overlay; // NOT YET IMPLEMENTED\n *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\n *\n *   constructor(overlayManager:OverlayManager) {\n *     this.overlay = overlay;\n *   }\n *\n *   onMouseEnter() {\n *     // exact signature to be determined\n *     this.overlay = this.overlayManager.open(text, ...);\n *   }\n *\n *   onMouseLeave() {\n *     this.overlay.close();\n *     this.overlay = null;\n *   }\n * }\n * ```\n * @publicModule angular2/annotations\n */\nexport class Decorator extends Directive {\n  compileChildren: boolean;\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle,\n      compileChildren = true,\n    }:{\n      selector:string,\n      bind:any,\n      events:any,\n      lifecycle:List,\n      compileChildren:boolean\n    }={})\n  {\n    this.compileChildren = compileChildren;\n    super({\n        selector: selector,\n        bind: bind,\n        events: events,\n        lifecycle: lifecycle\n    });\n  }\n}\n\n/**\n * Viewport is used for controlling the instatiation of inline templates.\n *\n * Viewport consist of a controller which can inject [ViewContainer]. A [ViewContainer] rerpsents a location in the\n * current view where child views can be inserted.\n *\n * ## Example\n *\n * Given folowing inline template, let's implement the `unless` behavior.\n *\n * ```\n * <ul>\n *   <li *unless=\"expr\"></li>\n * </ul>\n * ```\n *\n * Can be implemented using:\n *\n * ```\n * @Viewport({\n *   selector: '[unless]',\n *   bind: {\n *     'condition': 'unless'\n *   }\n * })\n * export class If {\n *   viewContainer: ViewContainer;\n *   prevCondition: boolean;\n *\n *   constructor(viewContainer: ViewContainer) {\n *     this.viewContainer = viewContainer;\n *     this.prevCondition = null;\n *   }\n *\n *   set condition(newCondition) {\n *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\n *       this.prevCondition = true;\n *       this.viewContainer.clear();\n *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\n *       this.prevCondition = false;\n *       this.viewContainer.create();\n *     }\n *   }\n * }\n * ```\n *\n *\n * @publicModule angular2/annotations\n */\nexport class Viewport extends Directive {\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle\n    }:{\n      selector:string,\n      bind:any,\n      lifecycle:List\n    }={})\n  {\n    super({\n        selector: selector,\n        bind: bind,\n        events: events,\n        lifecycle: lifecycle\n    });\n  }\n}\n\n//TODO(misko): turn into LifecycleEvent class once we switch to TypeScript;\n\n/**\n * Specify that a directive should be notified whenever a [View] that contains it is destroyed.\n *\n * ## Example\n *\n * ```\n * @Decorator({\n *   ...,\n *   lifecycle: [ onDestroy ]\n * })\n * class ClassSet implements OnDestroy {\n *   onDestroy() {\n *     // invoked to notify directive of the containing view destruction.\n *   }\n * }\n * ```\n * @publicModule angular2/annotations\n */\nexport const onDestroy = \"onDestroy\";\n\n\n/**\n * Specify that a directive should be notified when any of its bindings have changed.\n *\n * ## Example:\n *\n * ```\n * @Decorator({\n *   selector: '[class-set]',\n *   bind: {\n *     'propA': 'propA'\n *     'propB': 'propB'\n *   }\n * })\n * class ClassSet {\n *   propA;\n *   propB;\n *   onChange(changes:{[idx: string, PropertyUpdate]}) {\n *     // This will get called after any of the properties have been updated.\n *     if (changes['propA']) {\n *       // if propA was updated\n *     }\n *     if (changes['propA']) {\n *       // if propB was updated\n *     }\n *   }\n * }\n *  ```\n * @publicModule angular2/annotations\n */\nexport const onChange = \"onChange\";\n","$traceurRuntime.superConstructor($__placeholder__0).call($__placeholder__1)","assert.argumentTypes($__placeholder__0)","assert.type.$__placeholder__0)","return assert.returnType(($__placeholder__0), $__placeholder__1)","Object.defineProperty($__placeholder__0, $__placeholder__1,\n        {get: function() {return $__placeholder__2}});","($__placeholder__0 = $__placeholder__1.$__placeholder__2) === void 0 ?\n        $__placeholder__3 : $__placeholder__4","$__export($__placeholder__0, $__placeholder__1)"]}